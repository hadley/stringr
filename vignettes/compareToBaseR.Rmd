---
title: "Comparing stringr to base R"
author: "Sara Stoudt"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Comparing stringr to base R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette aims to compare stringr functions to base R equivalents to facilitate users transitioning from using base R to stringr. Following the groupings of functions from the [stringr cheat sheet](https://github.com/rstudio/cheatsheets/blob/master/strings.pdf), these are the base equivalents to stringr functions.

# Detect matches

| base | stringr    |
|------|------------|
|   `grepl(pattern, string)`   | `str_detect(string, pattern)` |
|   `grep(pattern, string)`   | `str_which(string, pattern)`  |
|   `gregexpr(pattern, string)`   | `str_count(string, pattern)`  |
|   `regexpr(pattern, string)`   | `str_locate(string, pattern)`  |
|   `gregexpr(pattern, string)`    | `str_locate_all(string, pattern)` |

# Subset strings

| base | stringr    |
|------|------------|
|   `substr(string, start, end)`   | `str_sub(string, start, end)`    |
|    `grep(pattern, string, value = TRUE)`  | `str_subset(string, pattern)` |
|   `regexpr(pattern, string)` + `regmatches()`   | `str_extract(string, pattern)`|
|   `regexec(patter, string)` + `regmatches()`   | `str_match(string, pattern)`  |


# Manage lengths

| base | stringr    |
|------|------------|
|   `nchar()`   | `str_length()` |
|  N/A    | `str_pad()`    |
|   N/A  | `str_trunc()`  |
|   `trimws()`   | `str_trim()`   |
|  `strwrap()`    | `str_wrap()`     |

# Mutate strings

| base | stringr        |
|------|----------------|
|  `substr(string, start, end)`    | `str_sub(string, start, end)`        |
|   `sub(pattern, replacement, string)`   | `str_replace(string, pattern, replacement)`    |
|   `gsub(pattern, replacement, string)`   | `str_replace_all(string, pattern, replacement)`|
|   `tolower()`   | `str_to_lower()`   |
|   `toupper()`   | `str_to_upper()`   |
|  `tools::toTitleCase()`    | `str_to_title()`   |


# Join and split

| base | stringr        |
|------|----------------|
|   `paste()`   | `str_c()`          |
|  `replicate()` + `paste()`    | `str_dup(string, times)`        |
|  `strsplit(string, pattern)`    | `str_split_fixed(string, pattern)`|
|   `paste()` + `eval()`   | `str_glue()`       |
|    `paste()`  | `str_glue_data()`  |

# Order strings

| base | stringr        |
|------|----------------|
|   `order()`   | `str_order()`      |
|   `sort()`   | `str_sort()`       |

# Helpers

| base | stringr      |
|------|--------------|
|  `iconv()`    | `str_conv()`     |
|  N/A    | `str_view()`     |
|   N/A   | `str_view_all()` |


```{r}
library(stringr)
```

Now we will walk through each of the functions in the above tables, noting the similarities and differences between base R and stringr.

These stringr examples come from the [stringr documentation](https://cran.r-project.org/web/packages/stringr/stringr.pdf) and here, they are contrasted with the analogous base R operation(s).

# Take-Aways

Overall the main differences between base R and stringr are:

1. The stringr package uses the `str_` prefix for its functions while base R has no unifying format for its functions.
2. The order of inputs is often (but not always) different between base R and stringr. In base R, the pattern often comes before the string while in stringr the expected input order is consistently the string first and then the pattern. The stringr order of inputs can be useful when using `apply()` or `purrr::map()` statements.
3. The stringr package provides more modular functionality. Many of the string processing functions in base R have multiple purposes while stringr's functions are each written to solve a single task.
4. The stringr package often returns outputs in a tidier format. Similar formats can be wrangled out of base R outpus, but often require more effort.



# Detect matches

## `str_detect()`: Detect the presence or absence of a pattern in a string

Suppose you want to know whether each word in a vector of fruit names contains an "a". 

```{r}
fruit <- c("apple", "banana", "pear", "pinapple")

# base
grepl(pattern = "a", x = fruit)

# stringr
str_detect(string = fruit, pattern = "a")
```

In base you would use `grepl()` (see the "l" and think logical) while in stringr you use `str_detect()` (see the verb "detect" and think of a yes/no action). Note the different order of inputs. `grepl()` expects the pattern of interest first while `str_detect()` expects the string first. 


## `str_which()`: Find positions matching a pattern

Now you want to identify the positions of the words in a vector of fruit names that contain an "a". 


```{r}
# base
grep(pattern = "a", x = fruit)

# stringr
str_which(string = fruit, pattern = "a")
```

In base you would use `grep()` while in stringr you use `str_which()` (analogous to `which()` returning matching positions). It should be noted that `grep()` is a versatile function. You will see it used again in this vignette for a different purpose.


## `str_count()`: Count the number of matches in a string

How many "a"s are in each fruit?

```{r}
# base 
gregexpr(pattern = "a", text = fruit, fixed = TRUE)


# stringr
str_count(string = fruit, pattern = "a")
```

This information can be gleaned from `gregexpr()` in base, but you will need to parse the output. This functionality is much more straightforward in stringr's `str_count()`. 

```{r}
results <- gregexpr(pattern = "a", text = fruit, fixed = TRUE)

lapply(results,function(x){length(attr(x,"match.length"))}) %>% unlist()
```



## `str_locate()`: Locate the position of patterns in a string

Within each fruit, where does the first "p" occur? all of the "p"s?

```{r}
# base
gregexpr(pattern = "p", text = fruit)

# stringr
str_locate(string = fruit, pattern = "p")
str_locate_all(string = fruit, pattern = "p")
```

Again we would need to parse the output of `gregexpr()` to get the information we want. The stringr package provides specialized functions, `str_locate()` and `str_locate_all()` to do the job. 

What if the pattern we request doesn't occur? `gregexpr()` returns a -1 for the `match.length` attribute while `str_locate()` returns NAs for the `start` and `end`.

```{r}
# base
gregexpr(pattern = "z", text = fruit)

# stringr
str_locate(string = fruit, pattern = "z")
```


# Subset strings

## `str_sub()`: Extract and replace substrings from a character vector

What if we want to grab part of a string?

```{r}
hw <- "Hadley Wickham"

# base
substr(x = hw, start = 1, stop = 6)
substring(text = hw , first = 1) 

# stringr
str_sub(string = hw, start = 1, end = 6)
str_sub(string = hw, start = 1)
str_sub(string = hw, end = 6)
```

In base you could use `substr()` or `substring()`. The former requires both a start and stop of the substring while the latter assumes the stop will be the end of the string. The stringr version, `str_sub()` has the same functionality, but also gives a default start value (the beginning of the string). Both the base and stringr functions have the same order of expected inputs. 

In stringr you can use negative numbers to help you choose your subset. The use of -1 as the `end` parameter will return up to and including the last character. The use of -2 will return up to the second to last character (and so on).

```{r}
# stringr
str_sub(string = hw ,start=1, end = -1)
str_sub(string = hw ,start=1, end = -2)
```

Both base R and stringr are vectorized for the substring functions. This means you can either choose the same subset across multiple strings or specify different subsets for different strings.

```{r}
al <- "Ada Lovelace"

# base
substr(x = c(hw,al), start = 1, stop = 6)

substr(x = c(hw,al), start = c(1,1), stop = c(6,7))

# stringr
str_sub(string = c(hw,al), start=1, end = -1)

str_sub(string = c(hw,al), start=c(1,1), end = c(-1,-2))
```

## `str_sub() <- `: Subset assignment

There are some differences in behavior between `str_sub()` and `substr()` when we are replacing substrings via assignment statements.

```{r}
# base
x <- "BBCDEF"
substr(x, 1, 1) <- "A"
x
substr(x, nchar(x), nchar(x)) <- "K"
x

substr(x, -2, -2) <- "GHIJ"
x

# stringr
x <- "BBCDEF"
str_sub(x, 1, 1) <- "A"
x
str_sub(x, -1, -1) <- "K"
x
str_sub(x, -2, -2) <- "GHIJ"
x # doesn't match

```

Base R's `substr()` has less capability to handle NAs than stringr's `str_sub()`.

```{r}
x1 <- x2 <- x3 <- "AAA"

# base
substr(x1, 1, NA) <- "B"
# substr(x2, 1, 2) <- NA ## Error: NA is invalid value

substr(x3, 1, NA) <- "B" ## no omit_na capability
x3

x1
x2
x3

# stringr
x1 <- x2 <- x3 <- x4 <- "AAA"

str_sub(x1, 1, NA) <- "B"
str_sub(x2, 1, 2) <- NA
str_sub(x3, 1, NA, omit_na = TRUE) <- "B"

x1
x2
x3
```


## `str_subset()`: Keep strings matching a pattern, or find positions

We may want to retrieve strings that contain a pattern of interest.

```{r}
# base
grep(pattern = "a", x = fruit, value = TRUE)


# stringr
str_subset(string = fruit, pattern = "a")
```

In base R we can use the value indicator in `grep()`. In stringr there is a specialized function: `str_subset()`.

## `str_extract()`: Extract matching patterns from a string

We may want to pick out certain patterns from a string, for example, the digits in a shopping list.

```{r}
shopping_list <- c("apples x4", "bag of flour", "bag of sugar", "milk x2")

# base
matches <- regexpr(pattern = "\\d", text = shopping_list) ## digits only
regmatches(x = shopping_list, m = matches)

gregexpr(pattern = "[a-z]+", text = shopping_list) 


# stringr
str_extract(string = shopping_list, pattern = "\\d") 
str_extract_all(shopping_list, "[a-z]+")

```

If we want to extract matches in base R we need to use the output of `regexpr()` as input to `regmatches()` whereas in stringr we would only  need one function call to `str_extract()`. If we want to extract all matches instead of just the first, we would need to wrangle the output of base R's `gregexpr()`. In stringr, there is a specialized function to do this: `str_extract_all()`.


## `str_match()`: Extract matched groups from a string

We may also want to extract groups from a string. Here I'm going to use the scenario from Section 14.4.3 in [R for Data Science](https://r4ds.had.co.nz/strings.html).

```{r}
head(sentences)
noun <- "(a|the) ([^ ]+)"
has_noun <- sentences %>%
  str_subset(noun) %>%
  head(5)
has_noun

# base
matches <- regexec(pattern = noun, text = has_noun)
do.call("rbind", regmatches(x = has_noun, m = matches))
gregexpr(pattern = noun, text = has_noun)

# stringr
str_match(string = has_noun, pattern = noun)
str_match_all(string = has_noun, pattern = noun)

```

The output of grouped matches is the full match and then the components of each group. Again, in base R we need to pair `regexec()` and `regmatches()` whereas in stringr we just need one function: `str_match()`. To get all the grouped matches in base R we would need to organize the output of `gregexpr()` whereas stringr's `str_match_all()` streamlines this process.

When an entry does not have a match, the stringr approaches maintain the correct dimensions of the output (using NAs or a matrix with 0 rows but the appropriate number of columns). In base R, `gregexpr()` also maintains the correct dimensions, but the `regmatches()` approach drops the entry that lacks the pattern. This can cause problems if we are making assumptions on the order and/or dimension of the output in further steps of our analysis.


```{r}
extra <- c(has_noun[1:3], "Wake and rise.", has_noun[4:5])

# base
matches <- regexec(pattern = noun, text = extra)
do.call("rbind", regmatches(x = extra, m = matches))
gregexpr(pattern = noun, text = extra)

# stringr
str_match(string = extra, pattern = noun)
test = str_match_all(string = extra, pattern = noun)
test

test[[6]] %>% dim()
```

# Manage lengths

## `str_length()`: The length of a string

To determine the length of a string, base R uses `nchar()` (not to be confused with `length()` which gives the length of vectors, etc.) while stringr uses `str_length()`.

```{r}
# base
nchar(letters)

# stringr
str_length(letters)

```

There are some subtle differences between base and stringr here. `nchar()` requires a character vector, so it will return an error if used on a factor. `str_length()` can handle a factor input.


```{r,error = T}
# base
nchar(factor("abc")) 
```

```{r}
# stringr
str_length(factor("abc"))
```

From the documentation: "Technically this [`str_length()`] returns the number of 'code points', in a string. One code point usually corresponds to one character, but not always."

```{r}
u1 <- "\u00fc"
u2 <- stringi::stri_trans_nfd(u1)

u1
u2

# base
nchar(u1) 
nchar(u2)


# stringr
str_length(u1)
str_length(u2)

```

## `str_pad()`: Pad a string

If you want to pad a string to a certain width, you can use stringr's `str_pad()`. In base R you could use `sprintf()`, but unlike `str_pad()`, `sprintf()` has many other functionalities. 

```{r}
# base
sprintf("%30s", "hadley")
sprintf("%-30s", "hadley")
# "both" is not as straightforward

# stringr
rbind(
  str_pad("hadley", 30, "left"),
  str_pad("hadley", 30, "right"),
  str_pad("hadley", 30, "both")
)

```


## `str_trunc()`: Truncate a character string

The stringr package provides an easy way to truncate a character string: `str_trunc()`. In base R you would have to do something a bit more complicated, potentially leveraging `substr()`.

```{r}
x <- "This string is moderately long"

# stringr
rbind(
  str_trunc(x, 20, "right"),
  str_trunc(x, 20, "left"),
  str_trunc(x, 20, "center")
)

```

## `str_trim()`: Trim whitespace from a string

Similarly, stringr provides `str_trim()` to trim whitespace from a string. This is analogous to base R's `trimws()` added in base version 3.5.3.

```{r}
# base
trimws(" String with trailing and leading white space\t")
trimws("\n\nString with trailing and leading white space\n\n")

# stringr
str_trim(" String with trailing and leading white space\t")
str_trim("\n\nString with trailing and leading white space\n\n")
```

The stringr function `str_squish()` allows for extra whitespace within a string to be trimmed (in contrast to `str_trim()` which removes whitespace at the beginning and/or end of string). In base R, one might take advantage of `gsub()` to accomplish the same effect.

```{r}
# stringr
str_squish(" String with trailing, middle,   and leading white space\t")
str_squish("\n\nString with excess, trailing and leading white space\n\n")
```

## `str_wrap()`: Wrap strings into nicely formatted paragraphs

Note that these implementations don't match. 

```{r}
thanks_path <- file.path(R.home("doc"), "THANKS")
thanks <- str_c(readLines(thanks_path), collapse = "\n")
thanks <- word(thanks, 1, 3, fixed("\n\n"))

# base
cat(strwrap(thanks, width = 80)) # match default width

# stringr
cat(str_wrap(thanks), "\n")
```


# Mutate strings

## `str_replace()`: Replace matched patterns in a string

To replace certain patterns within a string, stringr provides the functions `str_replace()` and `str_replace_all()`. The base R equivalents are `sub()` and `gsub()`. Note the difference in default input order again. In stringr the string comes first, followed by the pattern and replacement, while in base R, the pattern and replacment come before the string.

```{r}
fruits <- c("apple", "banana", "pear", "pinapple")

# base
sub("[aeiou]", "-", fruits)
gsub("[aeiou]", "-", fruits)

# stringr
str_replace(fruits, "[aeiou]", "-")
str_replace_all(fruits, "[aeiou]", "-")
```


## case: Convert case of a string

Both stringr and base R have functions to convert to upper and lower case.  Title case is also provided in stringr.


```{r}
dog <- "The quick brown dog"

# base
toupper(dog)
tolower(dog)
tools::toTitleCase(dog)

# stringr
str_to_upper(dog)
str_to_lower(dog)
str_to_title(dog)
```

In stringr we can control the locale, while in base R locale distinctions are controlled with global variables. Therefore, the output of your base R code may vary across different computers with different global settings.

```{r}
# stringr
str_to_upper("i") # English
str_to_upper("i", "tr") # Turkish
```

# Join and split

## `str_c()`: Join multiple strings into a single string

To join multiple strings into one, base R uses `paste()` or `paste0()` while stringr uses `str_c()` (the "c" stands for concatenate).

```{r}
# base
paste0("Letter: ", letters) # default separator is ""

# stringr
str_c("Letter: ", letters)
```

## `str_flatten()`: Flatten a string

If we want to take elements of a string vector and collapse them to a single string we can use the `collapse` argument in `paste()` or use stringr's `str_flatten()`.

```{r}
# base
paste0("Letter: ", letters, collapse = "")

# stringr
str_flatten(paste0("Letter: ", letters))
```


## `str_dup()`: Duplicate and concatenate strings within a character vector

The stringr package allows for more complicated concatenation of strings with functions such as `str_dup()`. In base R one would have to use a more complicated `paste()` expression to achieve the same result.

```{r}
# stringr
fruit <- c("apple", "pear", "banana")
str_dup(fruit, 2)
str_dup(fruit, 1:3)
str_c("ba", str_dup("na", 0:5))

```

## `str_split()`: Split up a string into pieces

To split a string into pieces with breaks based on a particular pattern match stringr uses `str_split()` and base R uses `strsplit()`. Unlike many of our other examples, when splitting a string into pieces, both base R and stringr use the same default order of inputs (string, then split criteria).

```{r}
fruits <- c(
  "apples and oranges and pears and bananas",
  "pineapples and mangos and guavas"
)
# base
strsplit(fruits, " and ")

# stringr
str_split(fruits, " and ")
```

The stringr package's `str_split()` allows for more control over the split, including restricting the number of possible matches.

```{r}
# stringr
str_split(fruits, " and ", n = 3)
str_split(fruits, " and ", n = 2)
```



## `str_glue()`: Format and interpolate a string with glue

You may want to combine strings and interpolate them at the same time. You can do this with a mix of `paste()` and `eval()` in base R, but stringr makes the process simpler with `str_glue()`.


```{r}
name <- "Fred"
age <- 50
anniversary <- as.Date("1991-10-12")

# base
paste("My name is ", name, ", my age next year is ", age+1, ", and my anniversary is ", format(anniversary, "%A, %B %d, %Y"), ".", sep = "")

# stringr
str_glue(
  "My name is {name}, ",
  "my age next year is {age + 1}, ",
  "and my anniversary is {format(anniversary, '%A, %B %d, %Y')}."
)
```

```{r}
# base
paste(rownames(mtcars), "has", mtcars$hp, "hp") %>% head()

# stringr
mtcars %>% str_glue_data("{rownames(.)} has {hp} hp") %>% head()
```


# Order strings

## `str_order()`: Order or sort a character vector

Both base R and stringr have separate functions to order and sort strings.

```{r}
# base
order(letters)
sort(letters)

# stringr
str_order(letters)
str_sort(letters)
```

Some options in `str_order()` and `str_sort()` don't have analogous base R options. For example, the stringr functions have a `locale` argument to control how to order or sort. In base R the locale is a global setting, so the outputs of `sort()` and `order()` may differ across different computers. The stringr functions also have a `numeric` argument to sort digits numerically instead of treating them as strings.


```{r}
# stringr
x <- c("100a10", "100a5", "2b", "2a")
str_sort(x)
str_sort(x, numeric = TRUE)
```


Note: [`stringi`](https://cran.r-project.org/web/packages/stringi/stringi.pdf) is another package for string processing that may be of interest to those doing a lot of text processing. This package has more capabilities than stringr and works at a finer grained level.