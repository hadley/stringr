---
title: "Comparing stringr to base R"
author: "Sara Stoudt"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette aims to compare stringr functions to base R equivalents. Following the groupings of functions from the [stringr cheat sheet](https://github.com/rstudio/cheatsheets/blob/master/strings.pdf), these are the base equivalents to stringr functions.

# Detect Matches

| base | stringr    |
|------|------------|
|   `grepl()`   | `str_detect()` |
|   `grep()`   | `str_which()`  |
|   `gregexpr()`   | `str_count()`  |
|  `gregexpr()`    | `str_locate()` |

# Subset Strings

| base | stringr    |
|------|------------|
|   `substr()`   | `str_sub()`    |
|    `grep()`  | `str_subset()` |
|   `regexpr()` + `regmatches()`   | `str_extract()`|
|      | `str_match()`  |


# Manage Lengths

| base | stringr    |
|------|------------|
|   `nchar()`   | `str_length()` |
|  `sprintf()`    | `str_pad()`    |
|   `substr()`   | `str_trunc()`  |
|   `trimws()`   | `str_trim()`   |

# Mutate Strings

| base | stringr        |
|------|----------------|
|  `substr()`    | `str_sub()`        |
|   `sub()`   | `str_replace()`    |
|   `gsub()`   | `str_replace_all()`|
|   `tolower()`   | `str_to_lower()`   |
|   `toupper()`   | `str_to_upper()`   |
|  `tools::toTitleCase()`    | `str_to_title()`   |


# Join and Split

| base | stringr        |
|------|----------------|
|   `paste()`   | `str_c()`          |
|  `replicate()` + `paste()`    | `str_dup()`        |
|  `strsplit()`    | `str_split_fixed()`|
|   `paste()` + `eval()`   | `str_glue()`       |
|    `paste()`  | `str_glue_data()`  |

# Order Strings

| base | stringr        |
|------|----------------|
|   `order()`   | `str_order()`      |
|   `sort()`   | `str_sort()`       |

# Helpers

| base | stringr      |
|------|--------------|
|  `iconv()`    | `str_conv()`     |
|  N/A    | `str_view()`     |
|   N/A   | `str_view_all()` |
|  `strwrap()`    | `str_wrap()`     |

```{r}
library(stringr)
```

The following examples walk through the examples in the stringr documentation and reproduce the results in base.

Note: In the following, I use base `apply` functions (rather than tidy [purrr](https://purrr.tidyverse.org/) functions) when illustrating the base alternative to the [stringr](https://stringr.tidyverse.org/) functions. 

## `str_c`

*Join multiple strings into a single string*

```{r}
## stringr
str_c("Letter: ", letters)

## base
paste("Letter: ", letters, sep = "")
```

```{r}
## stringr
str_c("Letter", letters, sep = ": ")

## base
paste("Letter", letters, sep = ": ")
```

## `str_conv`

*Specify the encoding of a string*

```{r}
x <- rawToChar(as.raw(177))
x

## stringr
str_conv(x, "ISO-8859-2") # Polish "a with ogonek"
str_conv(x, "ISO-8859-1") # Plus-minus

## base
iconv(x, "ISO-8859-2")
iconv(x, "ISO-8859-1")
```



## `str_count`

*Count the number of matches in a string.*

```{r}
fruit <- c("apple", "banana", "pear", "pinapple")

## stringr
str_count(fruit, "a")
str_count(fruit, "p")
str_count(fruit, "e")
str_count(c("a.", "...", ".a.a"), ".")


## base

# Example from: https://stackoverflow.com/questions/42394489/count-the-number-of-occurrences-of-in-a-string

# gregexpr returns starting positions of every (disjoint) match and a -1 if no match
# then we cnan sum the number of positions that are positive to get the number of matches

sapply((gregexpr("a", fruit, fixed=TRUE)), function(i) sum(i > 0))
sapply((gregexpr("p", fruit, fixed=TRUE)), function(i) sum(i > 0))
sapply((gregexpr("e", fruit, fixed=TRUE)), function(i) sum(i > 0))
sapply((gregexpr(".", c("a.", "...", ".a.a"), fixed=FALSE)), function(i) sum(i > 0))
```

Here are some trickier cases to reproduce in base R.

```{r}
## stringr
str_count(fruit, c("a", "b", "p", "p"))
str_count(c("a.", "...", ".a.a"), fixed("."))

## base
mapply(function(x,y){sapply(gregexpr(x, y, fixed=TRUE), function(i) sum(i > 0))},c("a", "b", "p", "p"),fruit) %>% unname()

sapply((gregexpr(".", c("a.", "...", ".a.a"), fixed=TRUE)), function(i) sum(i > 0))
```


## `str_detect`

*Detect the presence or absence of a pattern in a string*

```{r}
## stringr
str_detect(fruit, "a")
str_detect(fruit, "^a")
str_detect(fruit, "a$")
str_detect(fruit, "b")
str_detect(fruit, "[aeiou]")

## base
grepl("a", fruit)
grepl("^a", fruit)
grepl("a$", fruit)
grepl("b", fruit)
grepl("[aeiou]", fruit)
```

Here is a trickier case to reproduce in base R.

```{r}
## stringr
str_detect("aecfg", letters)


## base

eachResult <- lapply(unlist(str_split("aecfg", "")), function(x) {
  grepl(x, letters)
}) 

allResults = do.call("cbind",eachResult)

total = apply(allResults,1,sum) # is the letter one of c(a,e,c,f,g)?

ifelse(total>=1,T,F) # change to T/F
```


## `str_dup`

*Duplicate and concatenate strings within a character vector*

```{r}
## stringr
fruit <- c("apple", "pear", "banana")
str_dup(fruit, 2)
str_dup(fruit, 1:3)
str_c("ba", str_dup("na", 0:5))

## base
unlist(lapply(lapply(fruit, function(x) {
  replicate(2, x)
}), paste, collapse = ""))
## Example from https://stackoverflow.com/questions/22359127/how-to-repeat-a-string-n-times-in-r

unlist(lapply(mapply(function(x, y) {
  replicate(x, y)
}, 1:3, fruit), paste, collapse = ""))

paste("ba", unlist(lapply(lapply(0:5, function(x) {
  replicate(x, "na")
}), paste, collapse = "")), sep = "")
```

## `str_extract`

*Extract matching patterns from a string*

```{r}
shopping_list <- c("apples x4", "bag of flour", "bag of sugar", "milk x2")
str_extract(shopping_list, "\\d") ## digits only
str_extract(shopping_list, "[a-z]+") ## letters only

#https://stackoverflow.com/questions/47678725/how-to-do-str-extract-with-base-r
matches <-regexpr("\\d",shopping_list)
regmatches(shopping_list,matches)

matches <-regexpr("[a-z]+",shopping_list)
regmatches(shopping_list,matches)
```

## `str_flatten`

*Flatten a string*

```{r}
## stringr
str_flatten(letters)
str_flatten(letters, "-")

## base
paste(letters, collapse = "")
paste(letters, "-", sep = "", collapse = "")
```

## `str_glue`

*Format and interpolate a string with glue*


```{r}
name <- "Fred"
age <- 50
anniversary <- as.Date("1991-10-12")

## stringr
str_glue(
  "My name is {name}, ",
  "my age next year is {age + 1}, ",
  "and my anniversary is {format(anniversary, '%A, %B %d, %Y')}."
)

## base
paste("My name is ", eval(name), ", my age next year is ", eval(age + 1), ", and my anniversary is ", eval(format(anniversary, "%A, %B %d, %Y")), ".", sep = "")
```

```{r}
## stringr
mtcars %>% str_glue_data("{rownames(.)} has {hp} hp") %>% head()

## base
paste(rownames(mtcars), "has", mtcars$hp, "hp") %>% head()
```

## `str_length`

*The length of a string*

```{r}
## stringr
str_length(letters)
str_length(NA)
str_length(c("i", "like", "programming", NA))

## base
nchar(letters)
nchar(NA)
nchar(c("i", "like", "programming", NA))
```

Here are some tricker examples to reproduce in base R.

"Technically this [`str_length()`] returns the number of "code points", in a string. One code point usually corresponds to one character, but not always."

```{r,eval=F}
## stringr
str_length(factor("abc"))

## base
nchar(factor("abc")) ## Error in nchar(factor("abc")) : 'nchar()' requires a character vector
```

```{r}
u1 <- "\u00fc"
u2 <- stringi::stri_trans_nfd(u1)

u1
u2

## stringr
str_length(u1)
str_length(u2)

str_count(u1)
str_count(u2)

## base 
nchar(u1) ## matches length not count
nchar(u2)

length(u1) ## matches count not length
length(u2)
```


## `str_locate`

*Locate the position of patterns in a string.*

We need to clean up the ouput of `gregexpr()` to match that of `str_locate()`.

```{r}
fruit <- c("apple", "banana", "pear", "pineapple")

## stringr
str_locate(fruit, "$")
# "If the match is of length 0, (e.g. from a special match like $) end will be one character less than start."
str_locate(fruit, "a")
str_locate(fruit, "e")
str_locate(fruit, "ap")
str_locate(fruit, c("a", "b", "p", "p"))

## base
getOrganized <- function(x){

 start = x[1]
 start = ifelse(start<0,NA,start)
 
 lenEx = attr(x,"match.length")[1] ## just the first one
 
 end = ifelse(lenEx ==0, start-1,start+lenEx-1)
 end = ifelse(is.null(lenEx),NA,end)
 
 toReturn = cbind(start,end)
 
 toReturn
}

do.call("rbind",lapply(gregexpr("$", fruit),getOrganized))
do.call("rbind",lapply(gregexpr("a", fruit),getOrganized))
do.call("rbind",lapply(gregexpr("e", fruit),getOrganized))
do.call("rbind",lapply(gregexpr("ap", fruit),getOrganized))


do.call("rbind",mapply(function(x,y){do.call("rbind",lapply(gregexpr(x, y),getOrganized))},c("a", "b", "p", "p"),fruit,SIMPLIFY=F))
```

## `str_match`

*Extract matched groups from a string*

```{r}
strings <- c(
  " 219 733 8965", "329-293-8753 ", "banana", "595 794 7569",
  "387 287 6718", "apple", "233.398.9187 ", "482 952 3315",
  "239 923 8115 and 842 566 4692", "Work: 579-499-7527", "$1000",
  "Home: 543.355.3679"
)
phone <- "([2-9][0-9]{2})[- .]([0-9]{3})[- .]([0-9]{4})"
str_extract(strings, phone)
str_match(strings, phone)
```

```{r}
# Extract/match all
str_extract_all(strings, phone)
str_match_all(strings, phone)
x <- c("<a> <b>", "<a> <>", "<a>", "", NA)
str_match(x, "<(.*?)> <(.*?)>")
str_match_all(x, "<(.*?)>")
str_extract(x, "<.*?>")
str_extract_all(x, "<.*?>")
```


## `str_order`

*Order or sort a character vector*

```{r}
## stringr
str_order(letters)
str_sort(letters)

## base
order(letters)
sort(letters)
```


Some options in `str_order()` and `str_sort()` don't have analogous base R options.

```{r}
str_order(letters, locale = "haw") ## vowels come first
str_sort(letters, locale = "haw")
## no locale capability in order, sort
```

```{r}
x <- c("100a10", "100a5", "2b", "2a")
str_sort(x)
str_sort(x, numeric = TRUE)

sort(x)
## no numeric capability in sort
```

## `str_pad`

*Pad a string*

```{r}
## stringr
rbind(
  str_pad("hadley", 30, "left"),
  str_pad("hadley", 30, "right"),
  str_pad("hadley", 30, "both")
)

## base
sprintf("%30s", "hadley")
sprintf("%-30s", "hadley")

leftover <- 30 - nchar("hadley")
leftpad <- nchar("hadley") + floor(leftover / 2)

rbind(
  sprintf("%30s", "hadley"),
  sprintf("%-30s", "hadley"),
  sprintf("%-30s", sprintf(paste("%", leftpad, "s", sep = ""), "hadley"))
)
```

```{r}
## stringr
str_pad(c("a", "abc", "abcdef"), 10)
str_pad("a", c(5, 10, 20))
str_pad("a", 10, pad = c("-", "_", " "))
str_pad("hadley", 3) # Longer strings are returned unchanged


## base
sprintf("%10s", c("a", "abc", "abcdef"))

unlist(lapply(c(5, 10, 20), function(x) {
  sprintf(paste("%", x, "s", sep = ""), "a")
}))

unlist(lapply(c("-", "_", " "), function(x) {
  gsub(" ", x, sprintf("%10s", "a"))
}))


sprintf("%3s", "hadley")
```


##`str_remove`

*Remove matched patterns in a string*

```{r}
fruits <- c("one apple", "two pears", "three bananas")

## stringr
str_remove(fruits, "[aeiou]")
str_remove_all(fruits, "[aeiou]")

## base
sub("[aeiou]", "", fruits)
gsub("[aeiou]", "", fruits)
```

## `str_replace`

*Replace matched patterns in a string*

```{r}
## stringr
str_replace(fruits, "[aeiou]", "-")
str_replace_all(fruits, "[aeiou]", "-")

## base
sub("[aeiou]", "-", fruits)
gsub("[aeiou]", "-", fruits)
```

```{r}
## stringr
str_replace(fruits, "([aeiou])", "")
str_replace(fruits, "([aeiou])", "\\1\\1")

## base
sub("([aeiou])", "", fruits)
sub("([aeiou])", "\\1\\1", fruits)
```

```{r}
## stringr
str_replace(fruits, "[aeiou]", c("1", "2", "3"))
str_replace(fruits, c("a", "e", "i"), "-")

## base
mapply(function(x, y) {
  sub("[aeiou]", x, y)
}, c(1, 2, 3), fruits)

unname(mapply(function(x, y) {
  sub(x, "-", y)
}, c("a", "e", "i"), fruits))
```

```{r}
## stringr
str_replace_all(fruits, "[aeiou]", toupper)
str_replace_all(fruits, "b", NA_character_)

## base
chartr("[aeiou]","[AEIOU]", fruits)

#chartr("b",NA, fruits) ## NA is an invalid argument
ifelse(unlist(lapply(fruits,function(x){grepl("b",x)})),NA,fruits)
```


## `str_replace_na`

*Turn NA into "NA"*

```{r}
## stringr
str_replace_na(c(NA, "abc", "def"))

## base
# sub(NA,"NA",c(NA, "abc", "def")) ## doesn't work

input <- c(NA, "abc", "def")
ifelse(is.na(input), "NA", input)
```

## `str_split`

*Split up a string into pieces*

```{r}
fruits <- c(
  "apples and oranges and pears and bananas",
  "pineapples and mangos and guavas"
)

## stringr
str_split(fruits, " and ")

## base
strsplit(fruits, " and ")
```

```{r}
## stringr
str_split(fruits, " and ", simplify = T)

## base
## Example from https://stackoverflow.com/questions/17308551/do-callrbind-list-for-uneven-number-of-column
output <- strsplit(fruits, " and ")
outputDF <- lapply(output, function(x) {
  as.data.frame(t(x), stringsAsFactors = F)
})
simplified <- plyr::rbind.fill(outputDF)
simplified <- as.matrix(simplified)
simplified[which(is.na(simplified))] <- ""
unname(simplified)
```

```{r}
# Specify n to restrict the number of possible matches
str_split(fruits, " and ", n = 3)
str_split(fruits, " and ", n = 2)
# If n greater than number of pieces, no padding occurs
str_split(fruits, " and ", n = 5)
# Use fixed to return a character matrix
str_split_fixed(fruits, " and ", 3)
## same as str_split(fruits, " and ", 3, simplify = T)
str_split_fixed(fruits, " and ", 4)
```

## `str_sub`

*Extract and replace substrings from a character vector*

```{r}
hw <- "Hadley Wickham"

## stringr
str_sub(hw, 1, 6)
str_sub(hw, end = 6)

substr(hw, 1, 6)
## no default start and stop, need both
```

```{r}
## stringr
str_sub(hw, c(1, 8), c(6, 14))

## base
mapply(function(x, y) {
  substr(hw, x, y)
}, c(1, 8), c(6, 14))
```

```{r}
## stringr
str_sub(hw, -1)
str_sub(hw, -7)
str_sub(hw, end = -7)

## base
substr(hw, nchar(hw), nchar(hw))
substr(hw, nchar(hw) - 6, nchar(hw))
```

```{r}
## stringr
pos <- str_locate_all(hw, "[aeio]")[[1]]
str_sub(hw, pos)
str_sub(hw, pos[, 1], pos[, 2])

## base
apply(pos, 1, function(x) {
  substr(hw, x[1], x[2])
})
```

```{r}
## stringr
str_sub(hw, seq_len(str_length(hw)))
str_sub(hw, end = seq_len(str_length(hw)))

## base
unlist(lapply(seq_len(str_length(hw)), function(x) {
  substr(hw, 1, x)
}))

```

```{r}
## stringr
x <- "BBCDEF"
str_sub(x, 1, 1) <- "A"
x
str_sub(x, -1, -1) <- "K"
x
str_sub(x, -2, -2) <- "GHIJ"
x
str_sub(x, 2, -2) <- ""
x

## base
x <- "BBCDEF"
substr(x, 1, 1) <- "A"
x
substr(x, nchar(x), nchar(x)) <- "K"
x
substr(x, nchar(x) - 1, nchar(x) - 1) <- "GHIJ"
x ## different
substr(x, 2, nchar(x) - 1) <- ""
x
```

```{r,eval=F}
## stringr
x1 <- x2 <- x3 <- x4 <- "AAA"
str_sub(x1, 1, NA) <- "B"
str_sub(x2, 1, 2) <- NA
str_sub(x3, 1, NA, omit_na = TRUE) <- "B"
str_sub(x4, 1, 2, omit_na = TRUE) <- NA
x1
x2
x3
x4

x1 <- x2 <- x3 <- x4 <- "AAA"

## base
substr(x1, 1, NA) <- "B"
substr(x2, 1, 2) <- NA ## different
substr(x3, 1, NA) <- "B"
str_sub(x4, 1, 2, omit_na = TRUE) <- NA

x1
x2
x3
x4
```


## `str_subset`

*Keep strings matching a pattern, or find positions*

```{r}
fruit <- c("apple", "banana", "pear", "pinapple")

## stringr
str_subset(fruit, "a")
str_which(fruit, "a")

## base
grep("a", fruit, value = TRUE)
grep("a", fruit)
```

```{r}
## stringr
str_subset(fruit, "^a")
str_subset(fruit, "a$")
str_subset(fruit, "b")
str_subset(fruit, "[aeiou]")

## base
grep("^a", fruit, value = TRUE)
grep("a$", fruit, value = TRUE)
grep("b", fruit, value = TRUE)
grep("[aeiou]", fruit, value = TRUE)
```

```{r}
## stringr
str_subset(c("a", NA, "b"), ".")
str_which(c("a", NA, "b"), ".")

## base
grep(".", c("a", NA, "b"), value = TRUE)
grep(".", c("a", NA, "b"))
```


## `str_trim`

*Trim whitespace from a string*

```{r}
## stringr
str_trim(" String with trailing and leading white space\t")
str_trim("\n\nString with trailing and leading white space\n\n")

## base
trimws(" String with trailing and leading white space\t")
trimws("\n\nString with trailing and leading white space\n\n")
```


```{r}
## TO DO

## stringr
str_squish(" String with trailing, middle, and leading white space\t")
str_squish("\n\nString with excess, trailing and leading white space\n\n")
```

## `str_trunc`

*Truncate a character string*

```{r}
x <- "This string is moderately long"

## stringr
rbind(
  str_trunc(x, 20, "right"),
  str_trunc(x, 20, "left"),
  str_trunc(x, 20, "center")
)

## base
rbind(
  paste(substr(x, 1, 17), "...", sep = ""),

  paste("...", substr(x, nchar(x) - 16, nchar(x)), sep = ""),

  paste(substr(x, 1, ceiling(17 / 2)), "...", substr(x, nchar(x) - floor(17 / 2) + 1, nchar(x)), sep = "")
)

```

## `str_view`

*View HTML rendering of regular expression match*

```{r}
## stringr
str_view(c("abc", "def", "fgh"), "[aeiou]")
```

## `str_wrap`

*Wrap strings into nicely formatted paragraphs*

```{r}
thanks_path <- file.path(R.home("doc"), "THANKS")
thanks <- str_c(readLines(thanks_path), collapse = "\n")
thanks <- word(thanks, 1, 3, fixed("\n\n"))

## stringr
cat(str_wrap(thanks), "\n")
cat(str_wrap(thanks, width = 40), "\n")
cat(str_wrap(thanks, width = 60, indent = 2), "\n")
cat(str_wrap(thanks, width = 60, exdent = 2), "\n")
cat(str_wrap(thanks, width = 0, exdent = 2), "\n")

## base
cat(strwrap(thanks, width = 80), "\n") ## match default
cat(strwrap(thanks, width = 40), "\n")
cat(strwrap(thanks, width = 60, indent = 2), "\n")
cat(strwrap(thanks, width = 60, exdent = 2), "\n")
cat(strwrap(thanks, width = 0, exdent = 2), "\n")
```